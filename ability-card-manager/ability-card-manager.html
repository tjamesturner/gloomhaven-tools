<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Gloomhaven Card Browser</title>
    <style>
        body {
          font-family: Arial, sans-serif;
          margin: 20px;
          background: url('https://raw.githubusercontent.com/cmlenius/gloomhaven-card-browser/images/images/background.jpeg') repeat;
          background-size: auto;
        }

        .controls {
          display:flex;
          flex-wrap:wrap;
          gap:10px;
          align-items:center;
          margin-bottom:12px;
        }

        label { font-size:14px; margin-right:6px; }
        select, button { font-size:14px; padding:6px 8px; }

        #gallery {
          display:grid;
          grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
          gap:10px;
        }

        .card {
          position:relative;
          border-radius:8px;
          overflow:hidden;
          padding:4px;
          background:#fff;
          box-shadow:0 0 4px rgba(0,0,0,0.12);
          display:flex;
          align-items:center;
          justify-content:center;
        }

        .card img {
          width:100%;
          display:block;
          border-radius:6px;
          box-sizing:border-box;
          cursor:pointer;
        }

        /* Selection highlight */
        .selected {
          outline:4px solid gold;
          outline-offset:2px;
        }

        /* Area border colors (applied to .card via class) */
        .hand { border:3px solid #9e9e9e; }      /* gray */
        .play { border:3px solid #2e8b57; }      /* green */
        .discard { border:3px solid #ff8c00; }   /* orange */
        .active { border:3px solid #1e90ff; }    /* blue */
        .burn { border:3px solid #d32f2f; }      /* red */

        /* Quick-set buttons */
        #setHandBtn, #setPlayBtn {
          border-radius:6px;
          border:1px solid #aaa;
          background:#f2f2f2;
          cursor:pointer;
        }
        #setHandBtn:hover,#setPlayBtn:hover { background:#e0e0e0; }

        /* small screens: increase spacing */
        @media (max-width:480px){
          .controls { gap:8px; }
          select { font-size:13px; padding:6px; }
        }
    </style>
</head>
<body>
<div class="controls">
    <label>Mode:</label>
    <select id="modeSelector">
        <option value="setup">Setup</option>
        <option value="play">Play</option>
    </select>

    <label>Active Classes:</label>
    <select id="activeClasses" multiple size="4"></select>

    <label>Class:</label>
    <select id="classFilter"><option value="all">All</option></select>

    <label>Filter Area:</label>
    <select id="areaFilter">
        <option value="all">All</option>
        <option value="hand">Hand</option>
        <option value="play">Play</option>
        <option value="discard">Discard</option>
        <option value="active">Active</option>
        <option value="burn">Burn</option>
    </select>
</div>

<div class="controls">
    <label>Update Area for Selected:</label>
    <select id="bulkAreaSelect">
        <option value="">--Select Area--</option>
        <option value="hand">Hand</option>
        <option value="play">Play</option>
        <option value="discard">Discard</option>
        <option value="active">Active</option>
        <option value="burn">Burn</option>
    </select>

    <button id="setHandBtn">Hand</button>
    <button id="setPlayBtn">Play</button>
</div>

<div id="gallery"></div>

<script type="module">
    /* index.html (module) - expects ./config.js exporting: export const images = [...]; export const allClasses = [...]; */
    import { images, allClasses } from './config.js';

    /* DOM references */
    const gallery = document.getElementById('gallery');
    const modeSelector = document.getElementById('modeSelector');
    const activeClassesSelect = document.getElementById('activeClasses');
    const classFilter = document.getElementById('classFilter');
    const areaFilter = document.getElementById('areaFilter');
    const bulkAreaSelect = document.getElementById('bulkAreaSelect');
    const setHandBtn = document.getElementById('setHandBtn');
    const setPlayBtn = document.getElementById('setPlayBtn');

    /* constants */
    const playAreas = ["hand","play","discard","active","burn"];
    let selectedCards = new Set();

    /* --- persistence --- */
    function saveState(){
      const state = {
        mode: modeSelector.value,
        activeClasses: Array.from(activeClassesSelect.selectedOptions).map(o=>o.value),
        images // write the images array (status & playable are stored here)
      };
      localStorage.setItem('ghState', JSON.stringify(state));
    }
    function loadState(){
      const s = localStorage.getItem('ghState');
      if(!s) return;
      try{
        const obj = JSON.parse(s);
        if(obj.mode) modeSelector.value = obj.mode;
        if(Array.isArray(obj.activeClasses)){
          // ensure options exist first (we populate them before calling loadState in init)
          for(const opt of activeClassesSelect.options){
            opt.selected = obj.activeClasses.includes(opt.value);
          }
        }
        if(Array.isArray(obj.images)){
          // merge saved image properties into our images array by matching url
          const savedMap = new Map(obj.images.map(it => [it.url, it]));
          images.forEach(img => {
            const saved = savedMap.get(img.url);
            if(saved){
              if(typeof saved.status === 'string') img.status = saved.status;
              if(typeof saved.playable === 'boolean') img.playable = saved.playable;
            }
          });
        }
      }catch(e){
        console.warn('Failed to load state:', e);
      }
    }

    /* --- UI helpers --- */
    function populateActiveClasses(){
      activeClassesSelect.innerHTML = '';
      allClasses.forEach(cls=>{
        const opt = document.createElement('option');
        opt.value = cls;
        opt.textContent = cls;
        activeClassesSelect.appendChild(opt);
      });
    }
    function updateClassFilter(){
      const selected = Array.from(activeClassesSelect.selectedOptions).map(o=>o.value);
      classFilter.innerHTML = '<option value="all">All</option>';
      selected.forEach(cls=>{
        const opt = document.createElement('option');
        opt.value = cls;
        opt.textContent = cls;
        classFilter.appendChild(opt);
      });
    }

    /* --- rendering --- */
    function renderGallery(){
      const mode = modeSelector.value; // 'setup' or 'play'
      const areaVal = areaFilter.value; // 'all' or area
      const activeSelected = Array.from(activeClassesSelect.selectedOptions).map(o=>o.value);
      if(activeSelected.length === 0){
        gallery.innerHTML = '<p style="grid-column:1/-1;color:#666">No active classes selected.</p>';
        return;
      }
      const classVal = classFilter.value;

      // In setup mode, ensure playable cards are selected
      if(mode === 'setup'){
        // clear and repopulate selection with playable cards
        selectedCards.clear();
        images.forEach(img => { if(img.playable) selectedCards.add(img); });
      }

      gallery.innerHTML = '';
      images.forEach(img=>{
        // filter by active classes / class filter
        if(!activeSelected.includes(img.class)) return;
        if(classVal !== 'all' && img.class !== classVal) return;

        // filter by playability in play mode
        if(mode === 'play' && !img.playable) return;

        // filter by area filter
        if(areaVal !== 'all' && img.status !== areaVal) return;

        // build card
        const card = document.createElement('div');
        card.className = 'card ' + (img.status || 'hand');

        // image
        const el = document.createElement('img');
        el.src = img.url;
        el.alt = img.class;

        // selection highlight
        if(selectedCards.has(img)) card.classList.add('selected');
        else card.classList.remove('selected');

        // click behavior
        el.addEventListener('click', () => {
          if(mode === 'setup'){
            // toggle playable and selection
            img.playable = !img.playable;
            if(img.playable) selectedCards.add(img);
            else selectedCards.delete(img);
          } else {
            // play mode: toggle selection only
            if(selectedCards.has(img)) selectedCards.delete(img);
            else selectedCards.add(img);
          }
          saveState();
          renderGallery();
        });

        card.appendChild(el);
        gallery.appendChild(card);
      });
    }

    /* --- bulk area update handler --- */
    bulkAreaSelect.addEventListener('change', () => {
      const newArea = bulkAreaSelect.value;
      if(!newArea) return;
      selectedCards.forEach(img => { img.status = newArea; });
      // clear selection after bulk update
      selectedCards.clear();
      bulkAreaSelect.value = '';
      saveState();
      renderGallery();
    });

    /* quick-set buttons apply the bulk selection */
    setHandBtn.addEventListener('click', () => {
      bulkAreaSelect.value = 'hand';
      bulkAreaSelect.dispatchEvent(new Event('change'));
    });
    setPlayBtn.addEventListener('click', () => {
      bulkAreaSelect.value = 'play';
      bulkAreaSelect.dispatchEvent(new Event('change'));
    });

    /* top filters events */
    /* changing the areaFilter should only FILTER the gallery (not change card statuses) */
    areaFilter.addEventListener('change', () => {
      renderGallery();
    });

    /* active classes: limit to 4, update class filter, persist */
    activeClassesSelect.addEventListener('change', () => {
      const sel = Array.from(activeClassesSelect.selectedOptions);
      if(sel.length > 4){
        // deselect the last selected and inform the user
        sel[sel.length - 1].selected = false;
        alert('You can select up to 4 active classes.');
      }
      updateClassFilter();
      saveState();
      renderGallery();
    });

    /* class filter changes */
    classFilter.addEventListener('change', renderGallery);

    /* mode change: switching to play clears all selected cards; switching to setup will select playable cards */
    modeSelector.addEventListener('change', () => {
      if(modeSelector.value === 'play') selectedCards.clear();
      else if(modeSelector.value === 'setup'){
        selectedCards.clear();
        images.forEach(img => { if(img.playable) selectedCards.add(img); });
      }
      saveState();
      renderGallery();
    });

    /* --- init --- */
    function init(){
      populateActiveClasses();
      loadState();            // will set mode, activeClasses selection, and image playable/status values
      updateClassFilter();
      renderGallery();
    }
    init();

</script>
</body>
</html>
